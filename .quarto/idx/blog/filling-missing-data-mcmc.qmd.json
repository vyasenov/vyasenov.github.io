{"title":"Filling in Missing Data with MCMC","markdown":{"yaml":{"title":"Filling in Missing Data with MCMC","date":"2025-01-31","categories":["missing data"]},"headingText":"Background","containsRefs":false,"markdown":"\n\n\nEvery dataset inevitably contains missing or incomplete values. Practitioners then face the dilemma of how to address these missing observations. A common approach, though potentially problematic, is to simply ignore them. I am guilty of doing this all too often. While convenient, ignoring missing data can introduce bias into analyses, particularly if the missingness is not entirely random. Moreover, throwing away data usually results in loss of statistical precision. Traditional methods for handling missing data, such as mean or median imputation, usually oversimplify the underlying data-generating process. Regression-based adjustments offer some improvement, but they rely on the linearity assumption.\n\nThis article introduces Markov Chain Monte Carlo (MCMC) as a robust and theoretically sound methodology for addressing missing data. Unlike arbitrary imputation methods, MCMC leverages the inherent information within the dataset to generate plausible values for the missing observations. The core principle of MCMC involves treating missing data as random variables and employing the algorithm to sample from their posterior distribution, thereby capturing the uncertainty and built-in structure within the data. The use of MCMC to draw observations repeatedly in the context of missing data is often referred to as Multiple Imputation (MI).\n\nLet’s break this down step by step, explore the underlying intuition, as well as an illustrative example, assuming a basic understanding of probability theory and Bayesian methods.\n\n## Notation\n\nTo keep things precise, let’s set up some notation. Let Y be the complete dataset, which we wish we had. We observe some, but not all observations of Y. Let’s split it into observed data $Y_{\\text{obs}}$, and missing (or incomplete) data $Y_{\\text{miss}}$, so that $Y = \\left( Y_{\\text{obs}}, Y_{\\text{miss}} \\right)$.\n\nAssume a model for the data parameterized by $\\theta$, that is $Y \\sim f(Y \\mid \\theta)$. A simple example would be that a univariate $Y$ is Gaussian with some unspecified mean and variance. Our goal is to estimate and fill in $Y_{\\text{miss}}$ by sampling from the posterior distribution\n\n  $$P(Y_{\\text{miss}} \\mid Y_{\\text{obs}}, \\theta).$$\n\nThe results and intuition hold also conditional on some covariates $X$, but for simplicity’s sake, I will keep that out of the notation for now.\n\n## A Closer Look\n\n### Definition\n\nMarkov Chain Monte Carlo is a powerful computational technique designed to draw observations from complex probability distributions that are difficult to directly sample from. This might happen because they do not have a nice closed-form analytical expression, or they do, but it’s too messy. Such distributions often arise in Bayesian statistics, where we aim to estimate the posterior distribution of parameters given observed data.\n\nThe “magic” of MCMC lies in its iterative nature. It begins with an initial guess for the parameter $\\theta$. Then, a sophisticated sampling algorithm, such as the Metropolis-Hastings or Gibbs sampler, is employed to generate a sequence of observations. These observations are not independent but are related to each other in a specific way, forming a [Markov chain](https://en.wikipedia.org/wiki/Markov_chain). Crucially, under certain conditions, this Markov chain will eventually converge to the true target distribution.\n\nIn the context of missing data, MCMC iteratively alternates between the $I$- and the $P$-steps. At the $t$-th iteration with current guess for $\\theta$ denoted $\\theta^t$, these steps are:\n\n::: {.callout-note title=\"Algorithm:\"}\n1. **The $I$-step (imputation)**: Draw $Y_{\\text{miss}}$ from $P(Y_{\\text{miss}} \\mid Y_{\\text{obs}}, \\theta^t)$. That is, from its conditional distribution given the observed data and current parameter estimates.\n2. **The $P$-step (posterior)**: Draw $\\theta^{t+1}$ from $P(\\theta \\mid Y_{\\text{obs}}, Y_{\\text{miss}}^{t+1})$. This is its posterior distribution given the observed data and the newly imputed $Y_{\\text{miss}}$.\n:::\n\nThis back-and-forth dance ensures that the imputed values reflect the uncertainty and structure of the data. And with enough iterations (large $t$) the chain will converge to our target, $P(Y_{\\text{miss}} \\mid Y_{\\text{obs}}, \\theta)$.\n\n*Software Packages*: [mcmc](https://www.rdocumentation.org/packages/mcmcr), [MCMCPack](https://www.rdocumentation.org/packages/MCMCpack), [mice](https://www.rdocumentation.org/packages/mice).\n\n### Practical Considerations\n\nConvergence diagnostics are crucial to ensure the MCMC chains have reached a stable equilibrium, as the initial values can significantly influence the results. In simple words, the chain should run long enough so that the posterior distribution does not change significantly after each additional iteration. It is also common to discard (or “burn”) an initial batch of values since they do not come from the final, stable posterior distribution. Additionally, computational costs can be a significant factor, especially for large datasets or complex models but efficient algorithms and parallel processing can help. Lastly, model specification is critical, as the choice of imputation model directly impacts the quality of the imputed values.\n\n## An Example\n\nLet’s walk through an example using a simple dataset with missing values. Suppose you have a dataset with two variables, $X$ and $Y$, where $Y \\sim N(\\beta_0 + \\beta_1 X, \\sigma^2)$, and some values of $Y$ are missing. We assume the following relationship:\n\n  $$Y = \\beta_0 + \\beta_1 X + \\epsilon,$$\n\nwhere $\\epsilon$ is an error term. We impose priors on $\\beta_0$, $\\beta_1$, and $\\sigma^2$ (which collectively comprise $\\theta$ in this example).\n\nWe begin with generating some fake data and introduce missingness in $Y$.\n\n```r\nrm(list=ls())\nset.seed(1988)\nlibrary(mice)\n\n# generate fake data\nn <- 100                  \nc <- 0.2                 \nX <- rnorm(n, mean = 5, sd = 2)\nbeta0 <- 2                 \nbeta1 <- 1.5              \nepsilon <- rnorm(n, mean = 0, sd = 1)  \nY <- beta0 + beta1 * X + epsilon      \n\n# introduce missingness in Y\nmissing_indices <- sample(1:n, size = n * c, replace = FALSE)\nY[missing_indices] <- NA  \n\n# combine data into a data frame\ndata <- data.frame(X = X, Y = Y)\nhead(data)\n\n# perform imputation\nimputed_data <- mice(data, \n                    m = 5, \n                    method = \"norm\", \n                    seed = 1988)\nmodels <- with(imputed_data, lm(Y ~ X))\n\n# print results\nsummary(pool(models))\n\n         term estimate std.error statistic       df      p.value\n1 (Intercept) 1.730583 0.3008046  5.753179 49.51038 5.435802e-07\n2           X 1.546689 0.0544164 28.423207 52.02756 2.313802e-33\n```\n\nThis is clearly a silly example since $Y$ is missing at random, suggesting that missing data does not result in bias. Anyway, for illustration purposes we run the Bayesian Regression algorithm to fill in the missing $Y$ and proceed with a linear regression of $Y$ on $X$.\n\nSpecifically, the code below uses normal (linear regression) imputation to fill in the missing values. For each missing point the algorithm fits a linear regression model predicting $Y$ from $X$ using the complete data and then use this model to predict or impute the missing $Y$. This process is repeated $m$ times (hence the name multiple imputation), creating $m$ different versions of the dataset with the missing values filled in.\n\nBoth coefficients fall in the expected respective regions. \n\n## Where to Learn More\n\nFollowing some computational innovations, Bayesian methods have experienced somewhat of a revival in the last fifteen years. Consequently, there are plenty of high-quality materials online. [Takahashi (2017)](https://account.datascience.codata.org/index.php/up-j-dsj/article/view/dsj-2017-037) is an accessible resource on MCMC and Multiple Imputation which I used extensively.\n\n## Bottom Line\n\n- Missing data is an ever-present issue in practice.\n\n- Standard approaches to dealing with missing information include ignoring it or imputing it with mean or predicted values.\n\n- MCMC leverages the full joint distribution of the data, making it a robust imputation method.\n\n- By alternating between imputing missing values and updating parameters, MCMC aligns imputations with the observed data’s structure.\n\n## References\n\nGelman, A., Carlin, J. B., Stern, H. S., & Rubin, D. B. (1995). Bayesian data analysis. Chapman and Hall/CRC.\n\nRubin, D B 1987 Multiple Imputation for Nonresponse in Surveys. New York, NY: John Wiley & Sons. DOI: https://doi.org/10.1002/9780470316696\n\nSchafer, J L 1997 Analysis of Incomplete Multivariate Data. Boca Raton, FL: Chapman & Hall/CRC. DOI: https://doi.org/10.1201/9781439821862\n\nScheuren, F 2005 Multiple imputation: How it began and continues. The American Statistician, 59(4): 315–319.\n\nTakahashi, M. (2017). Statistical inference in missing data by MCMC and non-MCMC multiple imputation algorithms: Assessing the effects of between-imputation iterations. Data Science Journal, 16, 37-37.","srcMarkdownNoYaml":"\n\n## Background\n\nEvery dataset inevitably contains missing or incomplete values. Practitioners then face the dilemma of how to address these missing observations. A common approach, though potentially problematic, is to simply ignore them. I am guilty of doing this all too often. While convenient, ignoring missing data can introduce bias into analyses, particularly if the missingness is not entirely random. Moreover, throwing away data usually results in loss of statistical precision. Traditional methods for handling missing data, such as mean or median imputation, usually oversimplify the underlying data-generating process. Regression-based adjustments offer some improvement, but they rely on the linearity assumption.\n\nThis article introduces Markov Chain Monte Carlo (MCMC) as a robust and theoretically sound methodology for addressing missing data. Unlike arbitrary imputation methods, MCMC leverages the inherent information within the dataset to generate plausible values for the missing observations. The core principle of MCMC involves treating missing data as random variables and employing the algorithm to sample from their posterior distribution, thereby capturing the uncertainty and built-in structure within the data. The use of MCMC to draw observations repeatedly in the context of missing data is often referred to as Multiple Imputation (MI).\n\nLet’s break this down step by step, explore the underlying intuition, as well as an illustrative example, assuming a basic understanding of probability theory and Bayesian methods.\n\n## Notation\n\nTo keep things precise, let’s set up some notation. Let Y be the complete dataset, which we wish we had. We observe some, but not all observations of Y. Let’s split it into observed data $Y_{\\text{obs}}$, and missing (or incomplete) data $Y_{\\text{miss}}$, so that $Y = \\left( Y_{\\text{obs}}, Y_{\\text{miss}} \\right)$.\n\nAssume a model for the data parameterized by $\\theta$, that is $Y \\sim f(Y \\mid \\theta)$. A simple example would be that a univariate $Y$ is Gaussian with some unspecified mean and variance. Our goal is to estimate and fill in $Y_{\\text{miss}}$ by sampling from the posterior distribution\n\n  $$P(Y_{\\text{miss}} \\mid Y_{\\text{obs}}, \\theta).$$\n\nThe results and intuition hold also conditional on some covariates $X$, but for simplicity’s sake, I will keep that out of the notation for now.\n\n## A Closer Look\n\n### Definition\n\nMarkov Chain Monte Carlo is a powerful computational technique designed to draw observations from complex probability distributions that are difficult to directly sample from. This might happen because they do not have a nice closed-form analytical expression, or they do, but it’s too messy. Such distributions often arise in Bayesian statistics, where we aim to estimate the posterior distribution of parameters given observed data.\n\nThe “magic” of MCMC lies in its iterative nature. It begins with an initial guess for the parameter $\\theta$. Then, a sophisticated sampling algorithm, such as the Metropolis-Hastings or Gibbs sampler, is employed to generate a sequence of observations. These observations are not independent but are related to each other in a specific way, forming a [Markov chain](https://en.wikipedia.org/wiki/Markov_chain). Crucially, under certain conditions, this Markov chain will eventually converge to the true target distribution.\n\nIn the context of missing data, MCMC iteratively alternates between the $I$- and the $P$-steps. At the $t$-th iteration with current guess for $\\theta$ denoted $\\theta^t$, these steps are:\n\n::: {.callout-note title=\"Algorithm:\"}\n1. **The $I$-step (imputation)**: Draw $Y_{\\text{miss}}$ from $P(Y_{\\text{miss}} \\mid Y_{\\text{obs}}, \\theta^t)$. That is, from its conditional distribution given the observed data and current parameter estimates.\n2. **The $P$-step (posterior)**: Draw $\\theta^{t+1}$ from $P(\\theta \\mid Y_{\\text{obs}}, Y_{\\text{miss}}^{t+1})$. This is its posterior distribution given the observed data and the newly imputed $Y_{\\text{miss}}$.\n:::\n\nThis back-and-forth dance ensures that the imputed values reflect the uncertainty and structure of the data. And with enough iterations (large $t$) the chain will converge to our target, $P(Y_{\\text{miss}} \\mid Y_{\\text{obs}}, \\theta)$.\n\n*Software Packages*: [mcmc](https://www.rdocumentation.org/packages/mcmcr), [MCMCPack](https://www.rdocumentation.org/packages/MCMCpack), [mice](https://www.rdocumentation.org/packages/mice).\n\n### Practical Considerations\n\nConvergence diagnostics are crucial to ensure the MCMC chains have reached a stable equilibrium, as the initial values can significantly influence the results. In simple words, the chain should run long enough so that the posterior distribution does not change significantly after each additional iteration. It is also common to discard (or “burn”) an initial batch of values since they do not come from the final, stable posterior distribution. Additionally, computational costs can be a significant factor, especially for large datasets or complex models but efficient algorithms and parallel processing can help. Lastly, model specification is critical, as the choice of imputation model directly impacts the quality of the imputed values.\n\n## An Example\n\nLet’s walk through an example using a simple dataset with missing values. Suppose you have a dataset with two variables, $X$ and $Y$, where $Y \\sim N(\\beta_0 + \\beta_1 X, \\sigma^2)$, and some values of $Y$ are missing. We assume the following relationship:\n\n  $$Y = \\beta_0 + \\beta_1 X + \\epsilon,$$\n\nwhere $\\epsilon$ is an error term. We impose priors on $\\beta_0$, $\\beta_1$, and $\\sigma^2$ (which collectively comprise $\\theta$ in this example).\n\nWe begin with generating some fake data and introduce missingness in $Y$.\n\n```r\nrm(list=ls())\nset.seed(1988)\nlibrary(mice)\n\n# generate fake data\nn <- 100                  \nc <- 0.2                 \nX <- rnorm(n, mean = 5, sd = 2)\nbeta0 <- 2                 \nbeta1 <- 1.5              \nepsilon <- rnorm(n, mean = 0, sd = 1)  \nY <- beta0 + beta1 * X + epsilon      \n\n# introduce missingness in Y\nmissing_indices <- sample(1:n, size = n * c, replace = FALSE)\nY[missing_indices] <- NA  \n\n# combine data into a data frame\ndata <- data.frame(X = X, Y = Y)\nhead(data)\n\n# perform imputation\nimputed_data <- mice(data, \n                    m = 5, \n                    method = \"norm\", \n                    seed = 1988)\nmodels <- with(imputed_data, lm(Y ~ X))\n\n# print results\nsummary(pool(models))\n\n         term estimate std.error statistic       df      p.value\n1 (Intercept) 1.730583 0.3008046  5.753179 49.51038 5.435802e-07\n2           X 1.546689 0.0544164 28.423207 52.02756 2.313802e-33\n```\n\nThis is clearly a silly example since $Y$ is missing at random, suggesting that missing data does not result in bias. Anyway, for illustration purposes we run the Bayesian Regression algorithm to fill in the missing $Y$ and proceed with a linear regression of $Y$ on $X$.\n\nSpecifically, the code below uses normal (linear regression) imputation to fill in the missing values. For each missing point the algorithm fits a linear regression model predicting $Y$ from $X$ using the complete data and then use this model to predict or impute the missing $Y$. This process is repeated $m$ times (hence the name multiple imputation), creating $m$ different versions of the dataset with the missing values filled in.\n\nBoth coefficients fall in the expected respective regions. \n\n## Where to Learn More\n\nFollowing some computational innovations, Bayesian methods have experienced somewhat of a revival in the last fifteen years. Consequently, there are plenty of high-quality materials online. [Takahashi (2017)](https://account.datascience.codata.org/index.php/up-j-dsj/article/view/dsj-2017-037) is an accessible resource on MCMC and Multiple Imputation which I used extensively.\n\n## Bottom Line\n\n- Missing data is an ever-present issue in practice.\n\n- Standard approaches to dealing with missing information include ignoring it or imputing it with mean or predicted values.\n\n- MCMC leverages the full joint distribution of the data, making it a robust imputation method.\n\n- By alternating between imputing missing values and updating parameters, MCMC aligns imputations with the observed data’s structure.\n\n## References\n\nGelman, A., Carlin, J. B., Stern, H. S., & Rubin, D. B. (1995). Bayesian data analysis. Chapman and Hall/CRC.\n\nRubin, D B 1987 Multiple Imputation for Nonresponse in Surveys. New York, NY: John Wiley & Sons. DOI: https://doi.org/10.1002/9780470316696\n\nSchafer, J L 1997 Analysis of Incomplete Multivariate Data. Boca Raton, FL: Chapman & Hall/CRC. DOI: https://doi.org/10.1201/9781439821862\n\nScheuren, F 2005 Multiple imputation: How it began and continues. The American Statistician, 59(4): 315–319.\n\nTakahashi, M. (2017). Statistical inference in missing data by MCMC and non-MCMC multiple imputation algorithms: Assessing the effects of between-imputation iterations. Data Science Journal, 16, 37-37."},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../code/styles.css"],"toc":true,"include-in-header":[{"text":"<script src=\"../code/open-links-new-tab.js\"></script>\n"}],"filters":["code-insertion"],"output-file":"filling-missing-data-mcmc.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.7.24","resources":["../code/open-links-new-tab.js"],"theme":{"light":"cosmo","dark":"cyborg"},"header-includes":["<script type='text/javascript' src='https://platform-api.sharethis.com/js/sharethis.js#property=680ee8d89f7a510019a96bcf&product=inline-share-buttons' async='async'></script>"],"page-layout":"full","includes":{"after-body":["../_includes/comments.html"]},"insert-before-post":"_sharebuttons.md","title":"Filling in Missing Data with MCMC","date":"2025-01-31","categories":["missing data"]},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}